<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>SimonFeng的木屋</title>
    <link>https://simonf.cn/</link>
    
    <atom:link href="https://simonf.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>努力学习的后端工程师</description>
    <pubDate>Fri, 19 Apr 2024 12:42:53 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Java中数组的值传递</title>
      <link>https://simonf.cn/2024/04/19/Java%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92/</link>
      <guid>https://simonf.cn/2024/04/19/Java%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92/</guid>
      <pubDate>Fri, 19 Apr 2024 12:28:16 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;今天在做LeetCode27题（&lt;a href=&quot;https://leetcode.cn/problems/remove-element/%EF%BC%89%E6%97%B6%E5%8F%91%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E9%9</description>
        
      
      
      
      <content:encoded><![CDATA[<p>今天在做LeetCode27题（<a href="https://leetcode.cn/problems/remove-element/%EF%BC%89%E6%97%B6%E5%8F%91%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E8%A7%A3%E6%B3%95%E5%A6%82%E4%B8%8B%EF%BC%9A">https://leetcode.cn/problems/remove-element/）时发现了一个问题，我自己的解法如下：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: smionf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/04/19/16:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LC27RemoveElement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] newNums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            newNums[j]=nums[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums = newNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.length-count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lg</span> <span class="operator">=</span> removeElement(nums, <span class="number">3</span>);</span><br><span class="line">        System.out.println(lg);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的打印结果是[3,2,2,3]而不是[2,2,0,0]，没有通过debug发现原因。</p><p>查询资料（参考链接：<a href="https://www.cnblogs.com/PopShow/p/5207974.html">java 值传递 数组传递 - The_PopCore - 博客园 (cnblogs.com)</a>）发现原因如下：</p><p>以上代码中，虽然在<code>removeElement</code>方法中将符合条件的元素替换为0，但是在<code>main</code>方法中打印数组时，打印的仍然是原始的<code>nums</code>数组，而没有打印替换后的<code>nums</code>数组。这是因为Java中的数组是按值传递的，所以在<code>removeElement</code>方法中修改<code>nums</code>数组并不会影响<code>main</code>方法中的<code>nums</code>数组。</p><p>事例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str,<span class="type">char</span> ch,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">     </span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch = <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.i = i+<span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">     </span><br><span class="line">        <span class="type">Test</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        tt.change(tt.str,tt.ch[<span class="number">0</span>],tt.i);</span><br><span class="line">        System.out.println(tt.i);</span><br><span class="line">        System.out.print(tt.str+<span class="string">&quot; and &quot;</span>);</span><br><span class="line">        System.out.println(tt.ch);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>change()方法里的入参为char ch;</p><p>传递的是个char值的单个数组元素，此时ch&#x3D;’g’;是不影响源数组元素的。</p><p>this.i &#x3D; i+1;这里面等号左边的i是属性i，等号右边的i是局部变量（入参里的i）；</p><p>此时i+1后赋值给属性的i，自然会改变属性i的值，同时17行，tt.i又是调用属性的i，输出的结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line">good and abc</span><br></pre></td></tr></table></figure><p>顺带附上LeetCode27题我的解法：</p><p>题目：</p><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,3,0,4]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>这道题可以用双指针解法(快指针寻找新数组的元素 ，新数组就是不含有目标元素的数组，慢指针指向更新 新数组下标的位置)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simonf.array;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: smionf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2024/04/19/16:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LC27RemoveElement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//新数值元素的更新位置</span></span><br><span class="line">        <span class="type">int</span> fastIndex ;</span><br><span class="line">        <span class="keyword">for</span> (fastIndex = <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fastIndex] == val) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex];</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lg</span> <span class="operator">=</span> removeElement(nums, <span class="number">3</span>);</span><br><span class="line">        System.out.println(lg);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://simonf.cn/tags/Java/">Java</category>
      
      
      <comments>https://simonf.cn/2024/04/19/Java%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>提高代码运算效率，增加LeetCode代码通过率几种方法</title>
      <link>https://simonf.cn/2024/04/19/%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%BF%90%E7%AE%97%E6%95%88%E7%8E%87%EF%BC%8C%E5%A2%9E%E5%8A%A0LeetCode%E4%BB%A3%E7%A0%81%E9%80%9A%E8%BF%87%E7%8E%87%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <guid>https://simonf.cn/2024/04/19/%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%BF%90%E7%AE%97%E6%95%88%E7%8E%87%EF%BC%8C%E5%A2%9E%E5%8A%A0LeetCode%E4%BB%A3%E7%A0%81%E9%80%9A%E8%BF%87%E7%8E%87%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Fri, 19 Apr 2024 07:44:06 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;note1&quot;&gt;&lt;a href=&quot;#note1&quot; class=&quot;headerlink&quot; title=&quot;note1&quot;&gt;&lt;/a&gt;note1&lt;/h2&gt;&lt;p&gt;用位运算代替乘除法提高运算效率，例如:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="note1"><a href="#note1" class="headerlink" title="note1"></a>note1</h2><p>用位运算代替乘除法提高运算效率，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">8</span>&gt;&gt;<span class="number">1</span>); <span class="comment">//4 相当于8%(2^1)</span></span><br><span class="line">System.out.println(<span class="number">8</span>&gt;&gt;<span class="number">2</span>); <span class="comment">//2 相当于8%(2^2)</span></span><br><span class="line">System.out.println(<span class="number">8</span>&gt;&gt;<span class="number">3</span>); <span class="comment">//1 相当于8%(2^3)</span></span><br><span class="line">System.out.println(<span class="number">2</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//4 相当于2*(2^1)</span></span><br><span class="line">System.out.println(<span class="number">2</span>&lt;&lt;<span class="number">2</span>); <span class="comment">//8 相当于2*(2^2)</span></span><br><span class="line">System.out.println(<span class="number">2</span>&lt;&lt;<span class="number">3</span>); <span class="comment">//16 相当于2*(2^3)</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://simonf.cn/tags/LeetCode/">LeetCode</category>
      
      
      <comments>https://simonf.cn/2024/04/19/%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%BF%90%E7%AE%97%E6%95%88%E7%8E%87%EF%BC%8C%E5%A2%9E%E5%8A%A0LeetCode%E4%BB%A3%E7%A0%81%E9%80%9A%E8%BF%87%E7%8E%87%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RequestContextHolder类:持有上下文的Request容器</title>
      <link>https://simonf.cn/2024/04/08/RequestContextHolder%E7%B1%BB-%E6%8C%81%E6%9C%89%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84Request%E5%AE%B9%E5%99%A8/</link>
      <guid>https://simonf.cn/2024/04/08/RequestContextHolder%E7%B1%BB-%E6%8C%81%E6%9C%89%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84Request%E5%AE%B9%E5%99%A8/</guid>
      <pubDate>Mon, 08 Apr 2024 02:50:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;如果想在service层通过request获取请求报文中的信息，可以通过RequestContextHolder得到request对象。&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>如果想在service层通过request获取请求报文中的信息，可以通过RequestContextHolder得到request对象。</p><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  获取请求对象</span></span><br><span class="line"><span class="type">RequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line"><span class="comment">//  转化为ServletRequestAttributes</span></span><br><span class="line"><span class="type">ServletRequestAttributes</span> <span class="variable">sra</span> <span class="operator">=</span> (ServletRequestAttributes) requestAttributes;</span><br><span class="line"><span class="comment">//  获取到HttpServletRequest 对象</span></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> sra.getRequest();</span><br><span class="line"><span class="comment">//获取到HttpServletResponse 对象</span></span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> sra.getResponse();</span><br></pre></td></tr></table></figure><p>request 和 response 如何与RequestContextHolder进行挂钩的？看底层源码</p><p>首先分析RequestContextHolder这个类,里面有两个ThreadLocal保存当前线程下的request</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RequestContextHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 得到存储进去的request</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder = <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>(<span class="string">&quot;Request attributes&quot;</span>);</span><br><span class="line">    <span class="comment">//可被子线程继承的reques</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder = <span class="keyword">new</span> <span class="title class_">NamedInheritableThreadLocal</span>(<span class="string">&quot;Request context&quot;</span>);</span><br></pre></td></tr></table></figure><p>再看getRequestAttributes() 方法，相当于直接获取ThreadLocal里面的值,这样就保证了每一次获取到的Request是该请求的request.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestAttributes <span class="title function_">getRequestAttributes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (RequestAttributes)requestAttributesHolder.get();</span><br><span class="line">    <span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">        attributes = (RequestAttributes)inheritableRequestAttributesHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>request和response等是什么时候设置进去的?</p><p>springMVC 核心类DispatcherServlet 继承关系：DispatcherServlet -&gt; FrameworkServlet -&gt; HttpServletBean -&gt; HttpServlet</p><ol><li><code>HttpServletBean</code> 进行初始化工作</li><li><code>FrameworkServlet</code> 初始化 <code>WebApplicationContext</code>,并提供service方法预处理请</li><li><code>DispatcherServlet</code> 具体分发处理.</li></ol><p>那么就可以在<code>FrameworkServlet</code>查看到该类重写了service(),doGet(),doPost()…等方法,这些实现里面都有一个预处理方法<code>processRequest(request, response);</code>,所以定位到了我们要找的位置</p><p>查看<code>processRequest(request, response);</code>的实现,具体可以分为以下几步:</p><ol><li>获取上一个请求的参数</li><li>重新建立新的参数</li><li>设置到XXContextHolder</li><li>父类的service()处理请求</li><li>恢复request（恢复原来的LocaleContext和ServiceRequestAttributes到LocaleContextHolder和RequestContextHolder，避免影响Servlet以外的处理，如Filter</li><li>发布事件（发布ServletRequestHandlerEvent消息，这个请求是否执行成功都会发布消息）</li></ol>]]></content:encoded>
      
      
      
      <category domain="https://simonf.cn/tags/Java/">Java</category>
      
      
      <comments>https://simonf.cn/2024/04/08/RequestContextHolder%E7%B1%BB-%E6%8C%81%E6%9C%89%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84Request%E5%AE%B9%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MinIO上传文件报错:io.minio.errors.ErrorResponseException: The difference between the request time and the server&#39;s time is too large.</title>
      <link>https://simonf.cn/2024/04/03/MinIO%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99-io-minio-errors-ErrorResponseException-The-difference-between-the-request-time-and-the-server-s-time-is-too-large/</link>
      <guid>https://simonf.cn/2024/04/03/MinIO%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99-io-minio-errors-ErrorResponseException-The-difference-between-the-request-time-and-the-server-s-time-is-too-large/</guid>
      <pubDate>Wed, 03 Apr 2024 06:24:50 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;使用MinIO上传图片时报错：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class</description>
        
      
      
      
      <content:encoded><![CDATA[<p>使用MinIO上传图片时报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.minio.errors.ErrorResponseException: The difference between the request time and the server<span class="string">&#x27;s time is too large.</span></span><br></pre></td></tr></table></figure><p>这可能是因为linux服务器时间与windows时间不一致造成的。</p><p>在linux服务器里同步时间，方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第一步：安装ntp服务</span><br><span class="line">yum -y install ntp</span><br><span class="line">第二步：开启开机启动服务</span><br><span class="line">systemctl enable ntpd</span><br><span class="line">第三步：启动服务  Tips:联网正常前提下如果定时同步失败，先停止服务，再启动</span><br><span class="line">systemctl stop ntpd</span><br><span class="line">systemctl start ntpd</span><br><span class="line">第四步：更改时区</span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line">第五步：启用ntp同步</span><br><span class="line">timedatectl set-ntp yes</span><br><span class="line">第六步：同步时间</span><br><span class="line">ntpq -p</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://simonf.cn/tags/MinIO/">MinIO</category>
      
      
      <comments>https://simonf.cn/2024/04/03/MinIO%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99-io-minio-errors-ErrorResponseException-The-difference-between-the-request-time-and-the-server-s-time-is-too-large/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>排他锁理解，MySQL实践</title>
      <link>https://simonf.cn/2024/03/29/%E6%8E%92%E4%BB%96%E9%94%81%E7%90%86%E8%A7%A3%EF%BC%8CMySQL%E5%AE%9E%E8%B7%B5/</link>
      <guid>https://simonf.cn/2024/03/29/%E6%8E%92%E4%BB%96%E9%94%81%E7%90%86%E8%A7%A3%EF%BC%8CMySQL%E5%AE%9E%E8%B7%B5/</guid>
      <pubDate>Fri, 29 Mar 2024 02:59:24 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;先上定义：&lt;/p&gt;
&lt;p&gt;排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。&lt;/p&gt;
&lt;p&gt;在此先引入MySQL中锁的分</description>
        
      
      
      
      <content:encoded><![CDATA[<p>先上定义：</p><p>排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p><p>在此先引入MySQL中锁的分类：    </p><p><img src="/images/HexoBlog_2024-03-29_11-16-17.png">  </p><p>其中，独占锁是写锁，可理解为传统意义上的读写锁，读读不互斥，读写互斥，写写互斥。</p><p>排他锁用法：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM UPDATE;</span><br></pre></td></tr></table></figure><p>排他锁的申请前提：没有线程对该结果集中的任何行数据使用排他锁或共享锁，否则申请会阻塞。  </p><p>for update仅适用于InnoDB，且必须在事务块(BEGIN&#x2F;COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。    </p><p>验证排他锁，设计一张表：<br><img src="/images/HexoBlog_2024-03-29_11-19-17.png">                             </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 开启事务1 */</span><br><span class="line">BEGIN;</span><br><span class="line">/* 查询name为张三的数据并加上排他锁 */</span><br><span class="line">SELECT * FROM test WHERE name = &#x27;张三&#x27; FOR UPDATE;</span><br><span class="line">/* 延迟10秒执行 */</span><br><span class="line">SELECT SLEEP(10);</span><br><span class="line">/* 尝试修改  name = &#x27;张三&#x27; 的数据 */</span><br><span class="line">UPDATE test SET balance = 5000 WHERE name = &#x27;张三&#x27;;</span><br><span class="line">/* 延迟15秒执行 */</span><br><span class="line">SELECT SLEEP(15);</span><br><span class="line">/* 提交事务1 */</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>开启事务1的执行过程如下：  </p><p><img src="/images/HexoBlog_2024-03-29_11-27-17.png">  </p><p>同时开启事务二：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 开启事务2 */</span><br><span class="line">BEGIN;</span><br><span class="line">/* 普通查询name = &#x27;张三&#x27;的数据 */</span><br><span class="line">SELECT * FROM test WHERE name = &#x27;张三&#x27;;</span><br><span class="line">/* 提交事务2 */</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>事务二很快执行完成了，执行结果如下：</p><p><img src="/images/HexoBlog_2024-03-29_11-33-17.png">    </p><p>可以看出在事务一开启了排他锁以后，其他事务(事务二)仍然可以进行读操作，并产生了不可重复读的结果（在事务一没提交之前，事务一修改张三的余额为5000，事务二读取的张三的余额却为7000，待事务一执行完毕后，事务二读取的张三的余额变为5000）。  </p><p>如果事务一不变的情况下    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 开启事务1 */</span><br><span class="line">BEGIN;</span><br><span class="line">/* 查询name为张三的数据并加上排他锁 */</span><br><span class="line">SELECT * FROM test WHERE name = &#x27;张三&#x27; FOR UPDATE;</span><br><span class="line">/* 延迟10秒执行 */</span><br><span class="line">SELECT SLEEP(10);</span><br><span class="line">/* 尝试修改  name = &#x27;张三&#x27; 的数据 */</span><br><span class="line">UPDATE test SET balance = 5000 WHERE name = &#x27;张三&#x27;;</span><br><span class="line">/* 延迟15秒执行 */</span><br><span class="line">SELECT SLEEP(15);</span><br><span class="line">/* 提交事务1 */</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>事务二对张三的余额进行修改操作  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 开启事务2 */</span><br><span class="line">BEGIN;</span><br><span class="line">/* 尝试修改  name = &#x27;张三&#x27; 的数据 */</span><br><span class="line">UPDATE test SET balance = 2000 WHERE name = &#x27;张三&#x27;;</span><br><span class="line">/* 提交事务2 */</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p><img src="/images/HexoBlog_2024-03-29_11-48-17.png">    </p><p>可以看到在事务一开启排他锁的期间，事务二无法进行修改操作，等待20多秒事务一提交后才执行了事务二。事务二在事务一后执行，所以张三的余额被修改为2000。  </p><p><img src="/images/HexoBlog_2024-03-29_11-50-17.png"><br>————————————————</p><pre><code>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</code></pre><p>原文链接：<a href="https://blog.csdn.net/FENGBOKE/article/details/136166260">https://blog.csdn.net/FENGBOKE/article/details/136166260</a></p>]]></content:encoded>
      
      
      
      <category domain="https://simonf.cn/tags/MySQL/">MySQL</category>
      
      <category domain="https://simonf.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      <category domain="https://simonf.cn/tags/MySQL%E9%94%81/">MySQL锁</category>
      
      
      <comments>https://simonf.cn/2024/03/29/%E6%8E%92%E4%BB%96%E9%94%81%E7%90%86%E8%A7%A3%EF%BC%8CMySQL%E5%AE%9E%E8%B7%B5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ErrMsg:Nacos Server did not start because dumpservice bean construction failure :No DataSource set</title>
      <link>https://simonf.cn/2024/03/19/ErrMsg-Nacos-Server-did-not-start-because-dumpservice-bean-construction-failure-No-DataSource-set/</link>
      <guid>https://simonf.cn/2024/03/19/ErrMsg-Nacos-Server-did-not-start-because-dumpservice-bean-construction-failure-No-DataSource-set/</guid>
      <pubDate>Tue, 19 Mar 2024 03:33:18 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=Nacos&amp;spm=1001.2101.3001.7020&quot;&gt;Nacos&lt;/a&gt;有时候虽然可以正常启动，但是一访问&lt;a href=&quot;http://192.168.6.100:8848/&quot;&gt;ht</description>
        
      
      
      
      <content:encoded><![CDATA[<p><a href="https://so.csdn.net/so/search?q=Nacos&spm=1001.2101.3001.7020">Nacos</a>有时候虽然可以正常启动，但是一访问<a href="http://192.168.6.100:8848/">http://127.0.0.1:8848/</a>进程就会stopped。<a href="https://so.csdn.net/so/search?q=%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97&spm=1001.2101.3001.7020">查看日志</a>有这么一句报错：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ErrMsg:Nacos Server did not start because dumpservice bean construction failure :No DataSource set</span><br></pre></td></tr></table></figure><p>这有可能是数据库的连接没有释放导致的，可以尝试在数据库中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush hosts</span><br></pre></td></tr></table></figure><p>再尝试连接</p><p>然后可以查询下远程权限是否开放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select host,user from user</span><br></pre></td></tr></table></figure><p>如果没有开放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;</span><br></pre></td></tr></table></figure><p>开放远程权限再尝试启动Nacos，这时再访问Nacos问题得以解决。<br>————————————————</p><pre><code>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</code></pre><p>原文链接：<a href="https://blog.csdn.net/FENGBOKE/article/details/136579894">https://blog.csdn.net/FENGBOKE/article/details/136579894</a></p>]]></content:encoded>
      
      
      
      <category domain="https://simonf.cn/tags/Nacos/">Nacos</category>
      
      <category domain="https://simonf.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <comments>https://simonf.cn/2024/03/19/ErrMsg-Nacos-Server-did-not-start-because-dumpservice-bean-construction-failure-No-DataSource-set/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nacos异常：No DataSource set和Client not connected, current status:STARTING</title>
      <link>https://simonf.cn/2024/03/19/Nacos%E5%BC%82%E5%B8%B8%EF%BC%9ANo-DataSource-set%E5%92%8CClient-not-connected-current-status-STARTING/</link>
      <guid>https://simonf.cn/2024/03/19/Nacos%E5%BC%82%E5%B8%B8%EF%BC%9ANo-DataSource-set%E5%92%8CClient-not-connected-current-status-STARTING/</guid>
      <pubDate>Tue, 19 Mar 2024 03:19:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;今天遇到一个很有意思的问题：Nacos工作的好好的，一运行程序，nacos就自动stopped了。&lt;/p&gt;
&lt;p&gt;首先日志排查，linux命令：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</description>
        
      
      
      
      <content:encoded><![CDATA[<p>今天遇到一个很有意思的问题：Nacos工作的好好的，一运行程序，nacos就自动stopped了。</p><p>首先日志排查，linux命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs nacos</span><br></pre></td></tr></table></figure><p>初步怀疑是nacos启动后资源不足，但是日志里没有OutOfMemoryError等错误，但是日志里有这么一句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2024-03-08 22:07:25,713 ERROR Application run failed</span><br><span class="line"></span><br><span class="line">Nacos Server did not start because dumpservice bean construction failure : No DataSource set</span><br></pre></td></tr></table></figure><p>百度了一下发现是mysql配置文件出了问题，mysql8.0之后的版本, 需要在官网文档配置mysql的基础上加上<strong>mysql时区的设置。</strong></p><p><strong>像这样：</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">  <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/db_spzx?characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br></pre></td></tr></table></figure><p>运行程序后报了新的错误：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.alibaba.nacos.api.exception.NacosException: Client not connected, current status:STARTING</span><br></pre></td></tr></table></figure><p>依旧是百度了一下，发现nocos不仅需要配置中心地址，还得配置服务注册中心的地址。像这样：  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">simonf</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><p>加入了服务注册中心的地址重启项目，运行成功！</p><pre><code>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</code></pre><p>原文链接：<a href="https://blog.csdn.net/FENGBOKE/article/details/136573527">https://blog.csdn.net/FENGBOKE/article/details/136573527</a></p>]]></content:encoded>
      
      
      
      <category domain="https://simonf.cn/tags/Nacos/">Nacos</category>
      
      <category domain="https://simonf.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <comments>https://simonf.cn/2024/03/19/Nacos%E5%BC%82%E5%B8%B8%EF%BC%9ANo-DataSource-set%E5%92%8CClient-not-connected-current-status-STARTING/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo教程(一)|如何写文章并发布</title>
      <link>https://simonf.cn/2024/03/18/Hexo%E6%95%99%E7%A8%8B-%E4%B8%80-%E5%A6%82%E4%BD%95%E5%86%99%E6%96%87%E7%AB%A0%E5%B9%B6%E5%8F%91%E5%B8%83/</link>
      <guid>https://simonf.cn/2024/03/18/Hexo%E6%95%99%E7%A8%8B-%E4%B8%80-%E5%A6%82%E4%BD%95%E5%86%99%E6%96%87%E7%AB%A0%E5%B9%B6%E5%8F%91%E5%B8%83/</guid>
      <pubDate>Mon, 18 Mar 2024 13:06:28 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;创建新文章&quot;&gt;&lt;a href=&quot;#创建新文章&quot; class=&quot;headerlink&quot; title=&quot;创建新文章&quot;&gt;&lt;/a&gt;&lt;strong&gt;创建新文章&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在根目录下打开命令行，使用如下命令创建新文章：&lt;/p&gt;
&lt;figure class</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a><strong>创建新文章</strong></h3><p>在根目录下打开命令行，使用如下命令创建新文章：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="/images/HexoBlog_3_18.png"></p><p>md文档顶部自动生成的内容称之为<code>Front-matter</code>，即前置信息，用于给 Hexo 渲染该 md 文档，有很多的配置项可以自己添加：</p><p><img src="/images/HexoBlog_2024-03-18_21-13-56.png"></p><p>如何添加配置项:</p><p><img src="/images/HexoBlog_2024-03-18_21-17-17.png"></p><h3 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3><p>本地运行命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>部署命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>https://simonf.cn/2024/03/18/Hexo%E6%95%99%E7%A8%8B-%E4%B8%80-%E5%A6%82%E4%BD%95%E5%86%99%E6%96%87%E7%AB%A0%E5%B9%B6%E5%8F%91%E5%B8%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Loombook命名的坑</title>
      <link>https://simonf.cn/2023/10/01/Loombook%E5%91%BD%E5%90%8D%E7%9A%84%E5%9D%91/</link>
      <guid>https://simonf.cn/2023/10/01/Loombook%E5%91%BD%E5%90%8D%E7%9A%84%E5%9D%91/</guid>
      <pubDate>Sun, 01 Oct 2023 12:37:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;在写一个后台用户模块时，为了区分系统管理员和用户，命名时用使用了sUsername来命名系统管理员的名字，但是数据库注册管理员时一直没法注册成功。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</description>
        
      
      
      
      <content:encoded><![CDATA[<p>在写一个后台用户模块时，为了区分系统管理员和用户，命名时用使用了sUsername来命名系统管理员的名字，但是数据库注册管理员时一直没法注册成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema(description = &quot;系统管理员&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemUser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;管理员姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sUsername;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;管理员手机号码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经查源码发现sUsername的set方法在loombook中被命名为setSUsername，也就是说loombook中所有的属性的前两个字母必须小写！</p>]]></content:encoded>
      
      
      
      <category domain="https://simonf.cn/tags/Java/">Java</category>
      
      <category domain="https://simonf.cn/tags/Loombook/">Loombook</category>
      
      
      <comments>https://simonf.cn/2023/10/01/Loombook%E5%91%BD%E5%90%8D%E7%9A%84%E5%9D%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>枚举和包装类案例分析</title>
      <link>https://simonf.cn/2022/04/01/%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</link>
      <guid>https://simonf.cn/2022/04/01/%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</guid>
      <pubDate>Fri, 01 Apr 2022 10:50:07 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;枚举和包装类&quot;&gt;&lt;a href=&quot;#枚举和包装类&quot; class=&quot;headerlink&quot; title=&quot;枚举和包装类&quot;&gt;&lt;/a&gt;枚举和包装类&lt;/h2&gt;&lt;h3 id=&quot;阅读代码，分析运行结果：&quot;&gt;&lt;a href=&quot;#阅读代码，分析运行结果：&quot; class=&quot;head</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="枚举和包装类"><a href="#枚举和包装类" class="headerlink" title="枚举和包装类"></a>枚举和包装类</h2><h3 id="阅读代码，分析运行结果："><a href="#阅读代码，分析运行结果：" class="headerlink" title="阅读代码，分析运行结果："></a>阅读代码，分析运行结果：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br><span class="line">System.out.println(i1 == i3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码涉及到了Java中的自动装箱和拆箱的概念。</p><p>首先，我们需要了解Java中的整数缓存机制。Java中对于整数类型的缓存范围是在-128到127之间。当我们使用自动装箱将一个整数赋值给一个 <code>Integer</code> 对象时，如果该整数在缓存范围内，那么会直接返回缓存中的对象，而不会创建新的对象。</p><p>现在来分析代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br><span class="line">System.out.println(i1 == i3);</span><br></pre></td></tr></table></figure><p>在这段代码中，我们分别创建了两个 <code>Integer</code> 对象 <code>i1</code> 和 <code>i2</code>，并将它们都赋值为 <code>128</code>。然后，我们创建了两个 <code>int</code> 类型的变量 <code>i3</code> 和 <code>i4</code>，并同样赋值为 <code>128</code>。</p><p>接下来，我们分别使用 <code>==</code> 运算符进行比较。</p><p>第一个比较 <code>i1 == i2</code>，由于 <code>i1</code> 和 <code>i2</code> 都是通过自动装箱得到的 <code>Integer</code> 对象，而且 <code>128</code> 不在整数缓存范围内，所以 <code>i1</code> 和 <code>i2</code> 引用的是不同的对象，因此比较结果为 <code>false</code>。</p><p>第二个比较 <code>i3 == i4</code>，由于 <code>i3</code> 和 <code>i4</code> 都是基本类型的 <code>int</code>，直接进行数值比较，所以比较结果为 <code>true</code>。</p><p>第三个比较 <code>i1 == i3</code>，由于 <code>i1</code> 是 <code>Integer</code> 对象，而 <code>i3</code> 是基本类型的 <code>int</code>，在比较时会进行自动拆箱，将 <code>i1</code> 转换为 <code>int</code> 类型。然后进行数值比较，所以比较结果为 <code>true</code>。</p><p>总结起来，<code>i1 == i2</code> 的结果是 <code>false</code>，<code>i3 == i4</code> 和 <code>i1 == i3</code> 的结果都是 <code>true</code>。这是因为 <code>Integer</code> 对象的比较是通过自动拆箱后的数值比较来实现的。</p><h3 id="阅读代码，分析运行结果：-1"><a href="#阅读代码，分析运行结果：-1" class="headerlink" title="阅读代码，分析运行结果："></a>阅读代码，分析运行结果：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2.0</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2.0</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">2.0</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(c == d);</span><br><span class="line">System.out.println(a == d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码涉及到了Java中的自动装箱和拆箱的概念，和包装类的缓存机制。Double和Float包装类没有缓存对象。所以(a&#x3D;&#x3D;b)结果为true，(c&#x3D;&#x3D;d)结果为false，(a&#x3D;&#x3D;d)结果为true。</p>]]></content:encoded>
      
      
      
      <category domain="https://simonf.cn/tags/JavaSE/">JavaSE</category>
      
      <category domain="https://simonf.cn/tags/Java/">Java</category>
      
      <category domain="https://simonf.cn/tags/%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB/">枚举和包装类</category>
      
      
      <comments>https://simonf.cn/2022/04/01/%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
